"""
File: SimBuilder.py

This file will hold the class 'SimBuilder' which will construct a simulator from a python
dictionary. This dictionary will be the result of a parsed xml config file.

NOTE: This class will probably need to updated as more features are utilized in the graphical
interface.

Creation Date: 11/27/2021
Last Modified: 11/27/2021
Version: 1.3
"""

import os
import xmltodict
from simso.configuration import Configuration
from simso.core import Model


class SimBuilder:
	"""
	Class: SimBuilder

	This class can parse in an XML config and create a model accordingly. XML config files
	should be auto-generated by the SimSo GUI to prevent errors in the XML.
	"""

	def __init__(self, conf_file: str) -> None:
		"""
		Function: __init__

		This file is our constructor and it will initialize the SimBuilder class. Once this
		function has finished execution, there end user should be able to call the instance
		function run_model, and have the output available to them.

		:param conf_file: XML config filename to be parsed
		:type conf_file: str
		"""

		with open(conf_file, "r") as f:
			self._conf_dict = xmltodict.parse(f.read())['simulation']

		self._setup_config()
		self._setup_tasks()

		print(os.getcwd())
		self.config.check_all()

		self.model = Model(self.config)

	def _setup_config(self) -> None:
		"""
		Function: _setup_config

		This 'private' function will setup the Configuration object for the model.
		"""

		cd = self._conf_dict
		cd_sched = cd['sched']
		cd_proc = cd['processors']['processor']

		self.config = Configuration()
		self.config.cycles_per_ms = float(cd['@cycles_per_ms'])
		self.config.duration = float(cd['@duration'])
		self.config.etm = cd['@etm']
		self.config.scheduler_info.overhead = int(cd_sched['@overhead'])
		self.config.scheduler_info.overhead_activate = int(cd_sched['@overhead_activate'])
		self.config.scheduler_info.overhead_terminate = int(cd_sched['@overhead_terminate'])
		self.config.scheduler_info.filename = self._get_class_name(cd_sched.get('@className', ''))
		if cd_sched.get('@class'):
			self.config.scheduler_info.clas = cd_sched['@class']

		if isinstance(cd_proc, dict):
			self.config.add_processor(
				name = cd_proc["@name"],
				identifier= int(cd_proc["@id"]),
				cl_overhead = int(cd_proc["@cl_overhead"]),
				cs_overhead = int(cd_proc["@cs_overhead"]),
				speed = float(cd_proc["@speed"])
			)
		elif isinstance(cd_proc, list):
			for proc in cd_proc:
				self.config.add_processor(
					name = proc["@name"],
					identifier = int(proc["@id"]),
					cl_overhead = int(proc["@cl_overhead"]),
					cs_overhead = int(proc["@cs_overhead"]),
					speed = float(proc["@speed"])
				)

	def _setup_tasks(self) -> None:
		"""
		Function: _setup_task

		This 'private' function will create and add tasks to the model. Technically it adds
		them to the Configuration object.
		"""

		td = self._conf_dict['tasks']['task']

		if isinstance(td, dict):
			self.config.add_task(
				name = td['@name'],
				identifier = int(td['@id']),
				task_type = td['@task_type'],
				abort_on_miss = td['@abort_on_miss'],
				period = float(td["@period"]),
				activation_date = int(td['@activationDate']),
				list_activation_dates = td['@list_activation_dates'],
				deadline = float(td['@deadline']),
				base_cpi =float(td['@base_cpi']),
				mix = float(td['@mix']),
				wcet = float(td['@WCET']),
				acet = int(td['@ACET']),
				preemption_cost = int(td['@preemption_cost']),
				et_stddev = float(td['@et_stddev'])
			)
		elif isinstance(td, list):
			for task in td:
				self.config.add_task(
					name = task['@name'],
					identifier = int(task['@id']),
					task_type = task['@task_type'],
					abort_on_miss = task['@abort_on_miss'],
					period = float(task["@period"]),
					activation_date = float(task['@activationDate']),
					list_activation_dates = task['@list_activation_dates'],
					deadline = float(task['@deadline']),
					base_cpi =float(task['@base_cpi']),
					mix = float(task['@mix']),
					wcet = float(task['@WCET']),
					acet = float(task['@ACET']),
					preemption_cost = int(task['@preemption_cost']),
					et_stddev = float(task['@et_stddev'])
				)

	def _get_class_name(self, val: str) -> str:
		"""
		Function: _get_class_name

		This 'private' function will grab the file name per the correct file path from the XML.
		The XML file stores the path to a custom scheduler as if the root is graphic_config
		directory. The application assumes the root is cpre558-final-project. This fixes the
		relative pathing.

		:param val: Scheduler file path as it exists in the XML file
		:type val: str
		:return: Fixed relative path for the scheduler file
		:rtype: str
		"""
		return str(os.path.sep).join(val.split(os.path.sep)[-3:])

	def run_model(self) -> None:
		"""
		Function: run_model

		This function, when envoked by the end user, will execute the created model. This
		function has to be called in order to retrieve information about the task set and how
		the scheduler performed.
		"""

		self.model.run_model()
